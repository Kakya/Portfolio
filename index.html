<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">

    <title>Identity Map</title>
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css">
    <style>
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 3px;
        }

        .node text {
            font: 12px sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }

        <style > body {
            width: 960px;
            margin: 10px auto;
        }

        circle {
            fill: white;
            stroke: steelblue;
            stroke-width: 2px;
        }

        line {
            stroke: grey;
            stroke-width: 3px;
        }

        .incRect {
            stroke: grey;
            shape-rendering: crispEdges;
        }

        #incMatx text {
            text-anchor: middle;
            cursor: default;
        }

        #treesvg g text:hover, #treesvg g circle:hover {
            cursor: pointer;
        }

        #navdiv {
            background: #555;
        }

        #treesvg {
            border: 1px solid grey;
        }

        #labelpos {
            color: white;
        }

        #navdiv button, #navdiv textarea {
            vertical-align: middle;
        }

        #g_labels text {
            text-anchor: middle;
        }

        #g_elabels text {
            text-anchor: middle;
            fill: red;
            font-weight: bold;
        }

        .node {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1 id="Map Title"></h1>
    <h2><button onclick="createTree()">Add Identity</button></h2>
    <h3><button onclick="printTree()">Check all trees</button></h3>
    <h4 id = "Graph Title"><button onclick="createGraph()">Create Graph</button></h3>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="bootstrap.min.js"></script>
    <script src="bootbox.min.js"></script>
    <script>
        var newMap = 0;
        //Creates a tree object
        // l == name, p == parent, and c == array of children
        //Object has methods for adding to that uses manual redrawing
        var identities = [];
        var graphCreated = false;
        function createTree() {
            // var rootName = prompt("Please Enter ID Name", "");

            bootbox.prompt("Please enter the name of the ID", function (result) {
                var rootName = result;
                function Tree() {
                    var svgW = 958, svgH = 460, vRad = 12, tree = { cx: 300, cy: 30, w: 40, h: 70 };
                    //Tree DS definition
                    tree.vis = { v: 0, l: rootName, p: { x: tree.cx, y: tree.cy }, c: [] };
                    tree.size = 1;
                    tree.glabels = [];
                    tree.incMatx = [];
                    tree.incX = 500, tree.incY = 30, tree.incS = 20;

                    tree.getVertices = function () {
                        var v = [];
                        function getVertices(t, f) {
                            v.push({ v: t.v, l: t.l, p: t.p, f: f });
                            t.c.forEach(function (d) { return getVertices(d, { v: t.v, p: t.p }); });
                        }
                        getVertices(tree.vis, {});
                        return v.sort(function (a, b) { return a.v - b.v; });
                    }

                    tree.getEdges = function () {
                        var e = [];
                        function getEdges(_) {
                            _.c.forEach(function (d) { e.push({ v1: _.v, l1: _.l, p1: _.p, v2: d.v, l2: d.l, p2: d.p }); });
                            _.c.forEach(getEdges);
                        }
                        getEdges(tree.vis);
                        return e.sort(function (a, b) { return a.v2 - b.v2; });
                    }

                    tree.addLeaf = function (_, treeLev) {
                        var attrName;
                        bootbox.prompt("Please enter the name of the attribute", function (result) {
                            //alert(treeLev);
                            var tr = identities[treeLev - 1].vis;
                            attrName = result;
                            var leaf = { v: identities[treeLev - 1].size++, l: attrName, p: {}, c: [] };
                            function addLeaf(tr) {
                                if (tr.v == _) {
                                    //alert("Now adding");
                                    tr.c.push(leaf); return;
                                }
                                tr.c.forEach(addLeaf);
                            }
                            addLeaf(tr);
                            reposition(tr);
                            if (tree.glabels.length != 0) {
                                tree.glabels = []
                                relabel(
                                    {
                                        lbl: d3.range(0, tree.size).map(function (d) { return '?'; }),
                                        incMatx: d3.range(0, tree.size - 1).map(function () { return 0; })
                                    });
                                d3.select("#labelnav").style('visibility', 'hidden');
                            }
                            else tree.incMatx = d3.range(0, tree.size - 1).map(function () { return 0; });
                            redraw(treeLev);
                            redraw(treeLev);
                        });
                    }
                    redraw = function (treeLev) {

                        var edges = d3.select("#g_lines" + treeLev).selectAll('line').data(identities[treeLev-1].getEdges());

                        edges.transition().duration(500)
                            .attr('x1', function (d) { return d.p1.y; }).attr('y1', function (d) { return d.p1.x; })
                            .attr('x2', function (d) { return d.p2.y; }).attr('y2', function (d) { return d.p2.x; })

                        edges.enter().append('line')
                            .attr('x1', function (d) { return d.p1.y; }).attr('y1', function (d) { return d.p1.x; })
                            .attr('x2', function (d) { return d.p1.y; }).attr('y2', function (d) { return d.p1.x; })
                            .transition().duration(500)
                            .attr('x2', function (d) { return d.p2.y; }).attr('y2', function (d) { return d.p2.x; });


                        var labels = d3.select("#g_labels" + treeLev).selectAll('text').data(identities[treeLev-1].getVertices());

                        labels.text(function (d) { return d.l; }).transition().duration(500)
                            .attr('x', function (d) { return d.p.y; }).attr('y', function (d) { return d.p.x + 5; });

                        labels.enter().append('text').attr('x', function (d) { return d.f.p.y; }).attr('y', function (d) { return d.f.p.x + 5; })
                            .text(function (d) { return d.l; }).on('click', function (d) {
                                bootbox.dialog({
                                    message: "Please Select what to do",
                                    title: "What to do?",
                                    buttons: {
                                        addLeaf: {
                                            label: "Add a subattribute",
                                            className: "btn-addleaf",
                                            callback: function () {
                                                tree.addLeaf(d.v, treeLev);
                                            }
                                        },
                                        connectNode: {
                                            label: "Connect Nodes",
                                            className: "btn-connectNode",
                                            callback: function () {
                                                alert("Hi!");
                                            }
                                        }
                                    }
                                });
                            })
                            .transition().duration(500)
                            .attr('x', function (d) { return d.p.x; }).attr('y', function (d) { return d.p.y + 5; });

                        var elabels = d3.select("#g_elabels" + treeLev).selectAll('text').data(identities[treeLev-1].getEdges());
                        elabels
                            .attr('x', function (d) { return (d.p1.y + d.p2.y) / 2 + (d.p1.y < d.p2.y ? 8 : -8); }).attr('y', function (d) { return (d.p1.x + d.p2.x) / 2; })
                            .text(function (d) { return tree.glabels.length == 0 ? '' : Math.abs(d.l1 - d.l2); });

                        elabels.enter().append('text')
                            .attr('x', function (d) { return (d.p1.y + d.p2.y) / 2 + (d.p1.y < d.p2.y ? 8 : -8); }).attr('y', function (d) { return (d.p1.x + d.p2.x) / 2; })
                            .text(function (d) { return tree.glabels.length == 0 ? '' : Math.abs(d.l1 - d.l2); });
                    }

                    getLeafCount = function (_) {
                        if (_.c.length == 0) return 1;
                        else return _.c.map(getLeafCount).reduce(function (a, b) { return a + b; });
                    }
                    //Moves new nodes to correct position
                    reposition = function (v) {

                        var lC = getLeafCount(v), left = v.p.x - tree.w * (lC - 1) / 2;
                        v.c.forEach(function (d) {
                            var w = tree.w * getLeafCount(d);
                            left += w;
                            d.p = { x: left - (w + tree.w) / 2, y: v.p.y + tree.h };
                            reposition(d);
                        });
                    }

                    initialize = function () {
                        newMap++;
                        var mapNo=newMap;
                        d3.select("body").append("svg").attr("width", svgW).attr("height", svgH).attr('id', 'treesvg' + newMap);

                        d3.select("#treesvg" + newMap).append('g').attr('id', 'g_lines' + newMap).selectAll('line').data(tree.getEdges()).enter().append('line')
                            .attr('x1', function (d) { return d.p1.y; }).attr('y1', function (d) { return d.p1.x; })
                            .attr('x2', function (d) { return d.p2.y; }).attr('y2', function (d) { return d.p2.x; });
                        //Second Function that allows clicking and adding leaves
                        d3.select("#treesvg" + newMap).append('g').attr('id', 'g_labels' + newMap).selectAll('text').data(tree.getVertices()).enter().append('text')
                            .attr('x', function (d) { return d.p.y; }).attr('y', function (d) { return d.p.x + 5; }).text(function (d) { return d.l; })
                            .on('click', function (d) {
                                bootbox.dialog({
                                    message: "Please Select what to do",
                                    title: "What to do?",
                                    buttons: {
                                        addLeaf: {
                                            label: "Add a subattribute",
                                            className: "btn-addleaf",
                                            callback: function () {
                                                tree.addLeaf(d.v, mapNo);
                                            }
                                        },
                                        connectNode: {
                                            label: "Connect Nodes",
                                            className: "btn-connectNode",
                                            callback: function () {
                                                alert("Hi!");
                                            }
                                        }
                                    }
                                });
                            });

                        d3.select("#treesvg" + newMap).append('g').attr('id', 'g_elabels' + newMap).selectAll('text').data(tree.getEdges()).enter().append('text')
                            .attr('x', function (d) { return (d.p1.y + d.p2.y) / 2 + (d.p1.y < d.p2.y ? 8 : -8); }).attr('y', function (d) { return (d.p1.x + d.p2.x) / 2; })
                            .text(function (d) { return tree.glabels.length == 0 ? '' : Math.abs(d.l1 - d.l2); });

                    }
                    initialize();
                    return tree;
                }
                var tree = Tree();
                identities.push(tree);
            });
            
        }

        bootbox.prompt("Welcome! What will your map's name be?", function (result) 
        {
            if (result === null) 
            {
                bootbox.alert("Please Enter a Name");
            }
            else 
            {
                document.getElementById("Map Title").innerHTML = result;
            }
        });
        function treeCheck(tree)
        {
            console.log("Root name "+tree.l);
            tree.c.forEach(treeCheck);
        }
        function printTree()
        {
            for(var i = 0; i < identities.length; i++)
            {
                treeCheck(identities[i].vis);
            }
        }
        function createGraph()
        {
            var treeNum = 0;
            if(identities.length > 0)
            { 
                if(graphCreated)
                {
                    $(graphEins).remove();
                }
                graphCreated = true;               
                var width = 640;
                var height = 480;
                var nodes = [];
                function nodeFill (tree)
                {
                    nodes.push({"name": tree.l});
                    tree.c.forEach(nodeFill);
                }
                for(var k = 0; k < identities.length; k++)
                {
                    nodeFill(identities[k].vis);
                }            
                var links = [];
                function linkGenerate(tree)
                {
                    for(var l = 0; l < tree.c.length; l++)
                    {
                        for(var nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++)
                        {
                            if(tree.c[l].l === nodes[nodeIndex].name)
                            {
                                links.push({source: treeNum, target: nodeIndex});
                            }
                        }
                    }
                    treeNum++;
                    tree.c.forEach(linkGenerate);                   
                }
                for(var m = 0; m <identities.length; m++)
                {
                    linkGenerate(identities[m].vis);

                }
                console.log(links);
                var svg = d3.select('body').append('svg').attr('height', height).attr('width', width).attr('id', 'graphEins');
                var force = d3.layout.force()
                            .size([width, height])
                           .nodes(nodes)
                           .links(links)
                           .linkStrength(1);
                //force.linkDistance(width/2);
                var link = svg.selectAll('.link')
                           .data(links)
                           .enter().append('line')
                           .attr('class', 'link');
                var node = svg.selectAll('g.node')
                           .data(nodes)
                           .enter().append('g')
                           .attr('class', node)
                           .call(force.drag);
                node.append("text")
                    .text(function(d){return d.name;});
                force.on('tick', function() 
                    {
                        node.attr('r', width/25)
                            .attr('cx', function(d) { return d.x; })
                            .attr('cy', function(d) { return d.y; });
                        link.attr('x1', function(d) { return d.source.x; })
                            .attr('y1', function(d) { return d.source.y; })
                            .attr('x2', function(d) { return d.target.x; })
                            .attr('y2', function(d) { return d.target.y; });
                        node.attr("transform", function(d) { 
                           return 'translate(' + [d.x, d.y] + ')'; 
                       });
           
                    });       
                force.start();
            }
            else
            {
                bootbox.alert("Please create an Identity first");
            }
        }
    </script>
</body>
</html>
